\newcommand{\tn}{\textnormal}
\begin{algorithm*}[]
\label{alg:addr_pcode}
\small
\caption{Address Propagation Behavior}
\DontPrintSemicolon
\SetKw{Receive}{receive}
\SetKw{Compute}{compute}
\SetKw{Broadcast}{broadcast}
\SetKw{Coinflip}{coinflip}
\SetKw{Oracle}{verify}
\SetKw{Decide}{decide}
\SetKw{Decide}{decide}
\SetKwFor{On}{on}{do}{end}
\SetKwFor{Every}{every}{do}{end}
\SetKwFor{Indent}{}{}{}
\SetKwFor{At}{at}{}{}
\SetKwFor{Initially}{initially}{do}{end}
\SetKwFor{Procedure}{procedure}{}{}
\At {\tn{node $x$ store the following data:}} {
 %$now:$ current timestamp at node  \\
 \ds{addrMan}: a mapping from node $n$ to timestamp $ts$ \\
 list of connected peers, for each peer \Indent {} {
   $outbound$  // peer is an outbound connection \\
   \ds{addrKnown} // peer knows about address (can set/get)  \\
   \ds{addrBuf}   // set of addresses to send to peer \\
 }
}

\On {\Receive$(*, y)$ \textnormal{// any message received from peer $y$}} {
    \If {$y.outbound$ \textnormal{ // $y$ is an outbound connection}} {
      \lIf {$\ds{addrMan}[y].ts < (now-\tn{20 minutes}$)} {$\ds{addrMan}[y].ts \leftarrow now$
      }
    }
}

\On {\Receive(\tn{\msg{ADDR}[$addr\_vector$], $y$})    // ADDR message from peer y with addresses in addr\_vector} {
   \For {\tn{each address $a$ in $addr\_vector$}} {
      $y.\ds{addrKnown} \ll a$ \\
      \lIf {\tn{$a.ts$ is invalid (very old or 10+ minutes in the future)}} {
         $a.ts \leftarrow (now - \tn{5 hours})$}
      \If {$a.ts < (now - \tn{10 minutes})$  /* other conditions? */ } {
            choose 1-2 nodes $n$ uniformly at random   \\
            \textit{buffer-to-send}$(n, a)$
      }
      $\ds{addrMan}[a].ts \leftarrow (now - \tn{2 hours})$  // store in addrMan with a 2 hour penalty
   }
} 

\On {\Receive(\msg{GETADDR}, y)} {
    $y.\ds{addrBuf} \leftarrow \emptyset$  // clear send buffer \\
    $q \leftarrow$ up to 2500 addresses chosen uniformly at random from $\ds{addrMan}$  \\
    \textit{buffer-to-send}$(y, q)$
}

\On {\Receive(\msg{VERSION}, y) } {
    send \msg{GETADDR} to $y$ \\
    \lIf {y.outbound} {\textit{buffer-to-send}$(y, x)$
    }
 }

\Procedure{buffer-to-send(peer y, addr\_vector A)} {
    \For {\tn{each address $a$ in $A$}}
     {\lIf {$a \notin y.\ds{addrKnown}$} {$y.\ds{addrBuf} \ll a$}
    }
}

\Every {\tn{100 ms}} {
  \For{\tn{\tn{one randomly chosen connected peer $p$}}} {
    $p.\ds{addrKnown} \ll p.\ds{addrBuf}$ // upto 1000 $(addr, ts)$ in each message \\
    send $p.\ds{addrBuf}$ to $p$ and clear $p.\ds{addrBuf}$   // could be multiple messages \\
  }
 }

\Every {\tn{24 hours}} {
  \lFor{\tn{every connected node $p$}} {\textit{buffer-to-send}$(p, x)$
  }
}

\end{algorithm*}
