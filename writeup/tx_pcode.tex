\begin{algorithm*}[]
\label{alg:tx_pcode}
\small
\caption{Transaction Validation Behavior}
\DontPrintSemicolon
\SetKw{Receive}{receive}
\SetKw{Compute}{compute}
\SetKw{Broadcast}{broadcast}
\SetKw{Coinflip}{coinflip}
\SetKw{Oracle}{verify}
\SetKw{Decide}{decide}
\SetKw{Decide}{decide}
\SetKwFor{On}{on}{do}{end}
\SetKwFor{Every}{every}{do}{end}
\SetKwFor{Indent}{}{}{}
\SetKwFor{At}{at}{}{}
\SetKwFor{Initially}{initially}{do}{end}
\SetKwFor{Procedure}{procedure}{}{}
\At {\tn{node $x$ store the following data:}} {
 \ds{pcoinsTip}: tx in the current blockchain \\
 \ds{memPool}: valid tx relative to \ds{pcoinsTip} \\
 \ds{mapOrphans}: tx with inputs not in \ds{pcoinsTip} or \ds{memPool} \\
 \ds{mapAlreadyAskedFor}: map from transaction hash $h$ to queue of pairs (timestamp $ts$, peer $p$) means request $t$ from peer $p$ at time $ts$
 list of connected peers, for each peer \Indent {} {
   %\ds{invKnown}: set of transactions this peer already knows about \\
   \ds{mapAskFor}: pairs (timestamp $ts$, transaction hash $h$)
 }
}

\On {\Receive $(\msg{GETDATA}[items], y)$} {
  \For {\tn{each transaction hash $h$ in $items$}} {
    \If {$\exists \tx \in (\ds{memPool} \cup \ds{pcoinsTip}) \tn{ such that } \hash(\tx)=h$} {send $\msg{TX}[\tx]$ to $y$ // ignore requests for items in \ds{mapOrphans}
    }
  }
}

\On {\Receive$(\msg{INV}[items], y)$ \textnormal{// Inventory $items$ received from peer $y$}} {
  \For {\tn{each transaction hash $h$ in $items$}} {
    %$y.\ds{invKnown} \ll h$ \\
    \lIf {$\exists \tx \in (\ds{memPool} \cup \ds{pcoinsTip} \cup \ds{mapOrphans}) \tn{ such that } \hash(\tx)=h$} {discard $h$}
    \lIf {\tn{$\ds{mapAlreadyAskedFor}[h] = \emptyset$}} {$nRequestTime := now$}
    \lElse {$nRequestTime := max \{ ts | (ts,\_) \in \ds{mapAlreadyAskedFor}[h] \} $ + 2 minutes}
    $\ds{mapAlreadyAskedFor}[h] \ll (nRequestTime, y)$ \\
    $y.\ds{mapAskFor} \ll (nRequestTime, h)$
  }
}

\On {\Receive$(\msg{TX}[\tx], y)$ \textnormal{// transaction $\tx$ received from peer $y$}} {
    $\ds{mapAskFor}[\hash(\tx)] \leftarrow \emptyset$ // clear \ds{mapAskFor[\tx]} \\
    \lIf {$\tx \in (\ds{pcoinsTip} \cup \ds{memPool})$}
         {discard $\tx$}
    \lElseIf {\tn{an input in $\tx.inputs$ is already spent}} {discard $\tx$}
    \ElseIf {\tn{an input in $\tx.inputs$ is not in $(\ds{pcoinsTip} \cup \ds{memPool})$}} {
        $\ds{mapOrphans} \ll \tx$ \\
        \lIf{$|\ds{mapOrphans}| > 10\tn{k}$ } {evict one random tx from \ds{mapOrphans}
        }
    }
    \lElseIf {\tn{$\tx$ is invalid}} {set $y.setMisbehaving(-100)$}
    \lElse {recursive-accept($\tx$)}
}

\Procedure{recursive-accept($\tx$)} {
  $\ds{memPool} \ll \tx$ \\
  \For {\tn{$\tx' \in \ds{mapOrphans}$}} {
    \If {\tn{every input in $\tx'.inputs$ is in $(\ds{pcoinsTip} \cup \ds{memPool})$}} {
      \lIf {\tn{$\tx'$ is invalid}} {discard $\tx'$}
      \lElse {\textit{recursive-accept}$(\tx')$}
    }
  }
}

\Every{100 ms} {
  \For {\tn{each connected peer $p$}} {
    $vGetData := \emptyset$ \\
    \For {\tn{each (timestamp $ts$, hash $h$) in $p.\ds{mapAskFor}$}} {
      \If {$(ts > now)$} {
        $vGetData \ll h$ \\
        remove $(ts,h)$ from $p.\ds{mapAskFor}$ \\
      }
    }
    \lIf {$vGetData \ne \emptyset$} {send $\msg{GETDATA}[vGetData]$ to $p$}
  }
}

\end{algorithm*}
